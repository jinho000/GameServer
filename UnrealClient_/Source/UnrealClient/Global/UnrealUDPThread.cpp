#include "UnrealUDPThread.h"
#include <Sockets.h>
#include "../Packets/PacketConvertor.h"

UnrealUDPThread::UnrealUDPThread(ISocketSubsystem* _socketSubSystem, FSocket* _socket, TQueue<std::shared_ptr<ServerPacketBase>>* _recvQueue)
	: m_socketSubSystem(_socketSubSystem)
	, m_recvSocket(_socket)
	, m_pRecvQueue(_recvQueue)
	, m_bAppClose(true)
{
}

UnrealUDPThread::~UnrealUDPThread()
{
}

uint32 UnrealUDPThread::Run()
{
	// 리시브 처리 시작
	UE_LOG(LogTemp, Log, TEXT("UDP Recv Start"));

	while (m_bAppClose)
	{
		// Recv 동기 함수로 처리
		std::vector<uint8_t> recvBuffer;
		recvBuffer.resize(1024);
		int readBytes = 0;

		if (false == m_recvSocket->Recv(&recvBuffer[0], recvBuffer.size(), readBytes))
		{
			auto Result = m_recvSocket->GetConnectionState();

			switch (Result)
			{
			case SCS_NotConnected:
				break;
			case SCS_Connected:
			{
				// 서버가 종료되었을때
				// 에러는 분명하지만
				// 아직 소켓이 커넥트 상태라고 처리된다.
				// ThreadHandlerServerDestroy
				//ServerDestroyMessage SDM;
				//GameServerSerializer Sr;
				//SDM.Serialize(Sr);
				//MessageConverter Converter = MessageConverter(Sr.GetData());
				//MessageQueue_->Enqueue(Converter.GetServerMessage());
				return 0;
			}
			case SCS_ConnectionError:
				// 내가 직접 종료했을때
				// 아무것도 할필요가 없다.
				break;
			default:
				break;
			}

			// while문 종료
			m_bAppClose = false;
			break;
		}


		// 전달받은 패킷을 리시브 큐에 추가
		// 리시브 큐를 각 게임모드에 달린 패킷 컴포넌트 틱에서 처리
		PacketConvertor convertor(recvBuffer);
		check(nullptr != convertor.GetPacket());

		m_pRecvQueue->Enqueue(convertor.GetPacket());
	}


	return 0;
}

void UnrealUDPThread::Close()
{
	m_bAppClose = false;
}
